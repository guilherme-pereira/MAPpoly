% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mds.R
\name{mds_mappoly}
\alias{mds_mappoly}
\alias{mappoly.print.pcmap}
\alias{mappoly.print.pcmap3d}
\alias{mappoly.plot.pcmap}
\alias{mappoly.plot.pcmap3d}
\title{Estimates loci position using Multidimensional Scaling}
\usage{
mds_mappoly(input.mat, p = NULL, n = NULL, ndim = 2,
  weight.exponent = 2, verbose = TRUE)

mappoly.print.pcmap(x, ...)

mappoly.print.pcmap3d(x, ...)

mappoly.plot.pcmap(x, D1lim = NULL, D2lim = NULL,
  displaytext = FALSE, ...)

mappoly.plot.pcmap3d(x, D1lim = NULL, D2lim = NULL,
  displaytext = FALSE, ...)
}
\arguments{
\item{input.mat}{an object of class \code{mappoly.input.matrix}}

\item{p}{integer. The smoothing parameter for the principal curve.
If \code{NULL} (default) this will be done using the leave-one-out cross validation}

\item{n}{vector of integers or strings containing loci to be omitted from the analysis}

\item{ndim}{number of dimensions to be considered in the multidimensional scaling procedure (default = 2)}

\item{weight.exponent}{the exponent that should be used in the LOD score values to weight the
MDS procedure (default = 2)}

\item{verbose}{if \code{TRUE} (default), display information about the analysis}

\item{x}{an object of class \code{mappoly.mds}}

\item{...}{currently ignored}

\item{displaytext}{logical. If \code{TRUE}, display the name of the markers in the
diagnostic plot}
}
\value{
A list containing:
\item{M}{the input distance map}
\item{sm}{the unconstrained wMDS results}
\item{pc}{the principal curve results}
\item{distmap}{a matrix of pairwise distances between
loci where the columns are in the estimated order}
\item{locimap}{a data frame of the loci containing the name
and position of each locus in order of increasing distance}
\item{length}{integer giving the total length of the segment}
\item{removed}{a vector of the names of loci removed from the analysis}
\item{scale}{the scaling factor from the MDS}
\item{locikey}{a data frame showing the number associated with each
locus name for interpreting the MDS configuration plot}
\item{confplotno}{a data frame showing locus name associated
with each number on the MDS configuration plots}
}
\description{
Estimates loci position using Multidimensional Scaling proposed by
\cite{Preedy and Hackett (2016)}. The code is an adaptation from
the package \code{TetraploidSNPMap}, available under GNU GENERAL PUBLIC LICENSE,
Version 3, at
\url{https://github.com/BiomathematicsAndStatisticsScotland/TetraploidSNPMap}
}
\examples{
 \dontrun{
    data(hexafake)
    all.mrk<-make_seq_mappoly(hexafake, 'all')
    red.mrk<-elim_redundant(all.mrk)
    unique.mrks<-make_seq_mappoly(red.mrk)
    counts.web<-cache_counts_twopt(unique.mrks, get.from.web = TRUE)
    all.pairs<-est_pairwise_rf(input.seq = unique.mrks,
                               count.cache = counts.web,
                               n.clusters = 16,
                               verbose=TRUE)

    ## Full recombination fraction matrix
    mat.full<-rf_list_to_matrix(input.twopt=all.pairs)
    plot(mat.full)

    lgs <- group_mappoly(input.mat = mat.full,
                         input.seq = unique.mrks,
                         expected.groups = 3,
                         inter = TRUE,
                         comp.mat = TRUE, #this data has physical information
                         verbose=TRUE)
    lgs
    plot(lgs)
    lg1 <- make_seq_mappoly(lgs, 1)
    lg2 <- make_seq_mappoly(lgs, 2)
    lg3 <- make_seq_mappoly(lgs, 3)

    ##Plot matrices
    p1<-make_pairs_mappoly(input.seq = lg1, input.twopt = all.pairs)
    p2<-make_pairs_mappoly(input.seq = lg2, input.twopt = all.pairs)
    p3<-make_pairs_mappoly(input.seq = lg3, input.twopt = all.pairs)

    m1<-rf_list_to_matrix(input.twopt = p1)
    m2<-rf_list_to_matrix(input.twopt = p2)
    m3<-rf_list_to_matrix(input.twopt = p3)

    op<-par(mfrow = c(1,3), pty = "s")
    plot(m1, main.text = "LG1")
    plot(m2, main.text = "LG2")
    plot(m3, main.text = "LG3")
    par(op)

    ## Removing disruptive SNPs

    lg1.filt<-rf_snp_filter(p1, 5, 5, 0.15, thresh.perc = 0.05)
    lg2.filt<-rf_snp_filter(p2, 5, 5, 0.15, thresh.perc = 0.05)
    lg3.filt<-rf_snp_filter(p3, 5, 5, 0.15, thresh.perc = 0.05)

    p1.filt<-make_pairs_mappoly(input.seq = lg1.filt, input.twopt = all.pairs)
    p2.filt<-make_pairs_mappoly(input.seq = lg2.filt, input.twopt = all.pairs)
    p3.filt<-make_pairs_mappoly(input.seq = lg3.filt, input.twopt = all.pairs)

    m1.filt<-rf_list_to_matrix(input.twopt = p1.filt)
    m2.filt<-rf_list_to_matrix(input.twopt = p2.filt)
    m3.filt<-rf_list_to_matrix(input.twopt = p3.filt)

    op<-par(mfrow = c(2,3), pty = "s")
    plot(m1, main.text = "LG1")
    plot(m2, main.text = "LG2")
    plot(m3, main.text = "LG3")
    plot(m1.filt, main.text = "LG1.filt")
    plot(m2.filt, main.text = "LG2.filt")
    plot(m3.filt, main.text = "LG3.filt")
    par(op)
    mds.ord1 <- mds_mappoly(input.mat = m1.filt, p = NULL, n = NULL, ndim = 2)
    plot(mds.ord1)
    mds.ord1 <- mds_mappoly(input.mat = m1.filt, p = NULL,
                            n = c(346, 333), ndim = 2)
    plot(mds.ord1)
    mds.ord1 <- mds_mappoly(input.mat = m1.filt,
                           p = NULL, n = c(346, 333, 437, 445, 275,31),
                           ndim = 2)
    plot(mds.ord1)

    mds.ord2 <- mds_mappoly(input.mat = m2.filt, p = NULL, n = NULL, ndim = 2)
    plot(mds.ord2)
    mds.ord3 <- mds_mappoly(input.mat = m3.filt, p = NULL, n = NULL, ndim = 2)
    plot(mds.ord3)

    mds.seq.ord1 <- make_seq_mappoly(mds.ord1)
    mds.seq.ord2 <- make_seq_mappoly(mds.ord2)
    mds.seq.ord3 <- make_seq_mappoly(mds.ord3)


   }

}
\references{
Preedy, K. F., & Hackett, C. A. (2016). A rapid marker ordering approach for
 high-density genetic linkage maps in experimental autotetraploid populations
 using multidimensional scaling. _Theoretical and Applied Genetics_, 129(11),
 2117-2132. \url{http://doi.org/10.1007/s00122-016-2761-8}
}
\author{
Marcelo Mollinari, \email{mmollin@ncsu.edu} mostly adapted from TetraploidSNPMap codes
}
\keyword{internal}
